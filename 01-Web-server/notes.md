# Client - Server Architecture

- Client-Server architecture is a network design model where multiple clients (remote processors) request and receive services from a centralized server (host computer).

### Client

- A Client is a device or an application that requests services or resources from the server.
- Examples :
  1. web browsers,
  2. email clients, or any networked device.

### Server :

- A server is a powerful computer or software application that provides resources, services, or data to clients.
- Servers can manage network resources and handle multiple client requests simultaneously.
- Simply put, Server is just a software that's duty is to serve a request.
- Functions:
  1. File Server: Stores and manages files for network users.
  2. Database Server: Provides database services and manages database access.
  3. Mail Server: Manages and delivers email.
  4. Application Server: Hosts and runs applications, providing business logic for the applications.
  5. Proxy Server: Acts as an intermediary for requests from clients seeking resources from other servers.
- Examples :
  1. MySQL server for databases,
  2. Samba server for file sharing.

### Web server

- A web server is a specific type of server that delivers web content, such as HTML pages, images, and other resources, to clients (usually web browsers) over the HTTP or HTTPS protocols.
- Functions:
  1. Hosting Websites: Stores, processes, and delivers web pages to users.
  2. Handling HTTP Requests: Manages requests for web content from clients.
  3. Serving Static and Dynamic Content: Provides static files (e.g., HTML, CSS, JavaScript) and dynamic content generated by web applications.
  4. Security: Implements security measures like HTTPS, authentication, and access controls.
- Examples :
  1. Apache HTTP Server: An open-source web server widely used on Unix-like operating systems.
  2. Nginx: Known for its high performance and scalability, often used for handling high-traffic websites.

## Basic Client-Server Model

### Client-Server Interaction

1. The client sends a request to the server.
2. The server processes the request.
3. The server sends a response back to the client.

```
   +---------+               +---------+
   |  Client |<------------->|  Server |
   +---------+   Request      +---------+
       |          ------>          |
       |          <------          |
       |         Response          |
       +---------------------------+

```

## Multi-Tier Client-Server Architecture

- Multi-tier architecture, often called n-tier architecture, divides the application into layers or tiers, each responsible for a specific aspect of the application.
  1. Presentation Tier (Client):
     - The user interface and user interaction layer.
     - It sends user requests to the server and displays the response.
  2. Logic Tier (Application Server):
     - Processes the data received from the presentation tier and performs the necessary operations.
  3. Data Tier (Database Server):
     - Manages and retrieves data from the database.

### Client-Server Interaction

1. Client sends a request: The user interacts with the client application (e.g., a web browser), which sends a request to the server.
2. Server processes the request: The server receives the request, processes it, and performs necessary operations, possibly involving querying a database.
3. Server sends a response: The server sends the processed data or result back to the client.
4. Client displays the response: The client application receives the response and presents it to the user.

```
        +-------------+
        | Presentation|
        |     Tier    |
        |   (Client)  |
        +-------------+
                |
                | Request
                v
        +-------------+
        |   Logic     |
        |    Tier     |
        | (App Server)|
        +-------------+
                |
                | Database Query
                v
        +--------------+
        |    Data      |
        |    Tier      |
        |(Database Svr)|
        +--------------+
```

### Advantages of Client-Server Architecture

1. Centralized Management: Resources and data are managed centrally on the server.
2. Scalability: Servers can be upgraded independently of clients, and additional servers can be added to handle increased load.
3. Maintenance: Easier to update and maintain because changes can be made on the server without affecting the clients.

---

---

# NodeJs :

- Node.js is an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside a web browser.
- It is designed to build scalable network applications and is especially well-suited for creating real-time applications due to its event-driven, non-blocking I/O model.

## Key Features of Node.js

1. Asynchronous and Event-Driven:

   - All APIs of Node.js are asynchronous, meaning non-blocking.
   - It operates on a single-threaded event loop, allowing it to handle multiple connections concurrently.

2. Fast Execution:

   - Built on Google Chrome's V8 JavaScript engine, Node.js compiles JavaScript code directly into native machine code, resulting in very high performance.

3. Single Programming Language:

   - Allows developers to write both server-side and client-side code in JavaScript, fostering a more consistent and cohesive development experience.

4. NPM (Node Package Manager):

   - Provides a vast ecosystem of reusable libraries and modules, facilitating the rapid development of applications.

5. Scalability:

   - Suitable for microservices architecture, allowing applications to scale horizontally.

6. Cross-Platform:
   - Can be run on various operating systems such as Windows, Linux, Unix, and macOS.

## Working of Node.js

- Node.js operates on a single-threaded, event-driven architecture, which enables it to handle many connections concurrently with high performance.
- This is achieved through the use of an event loop and non-blocking I/O operations.

  - Step 1: Incoming Requests

    - When a client sends a request to a Node.js server, the request is placed into an event queue.

  - Step 2: Event Loop

    - The event loop continuously checks the event queue for new requests.
    - It processes these requests one at a time but can handle many requests due to its non-blocking nature.

  - Step 3: Non-Blocking I/O Operations

    - For I/O operations like reading from a database or a file, Node.js performs these operations asynchronously.
    - This means it initiates the operation and continues processing other tasks instead of waiting for the I/O operation to complete.

  - Step 4: Callback Execution
    - Once an I/O operation completes, the callback function associated with that operation is placed back into the event queue.
    - The event loop will pick up this callback and execute it when it gets to the front of the queue.

```
+------------------------------------------------------+
|                  Event Loop                          |
|                                                      |
|   +---------------------------------------------+    |
|   | Incoming Requests / Events                  |    |
|   +---------------------------------------------+    |
|          |         |       |        |                |
|          v         v       v        v                |
|   +---------------------------------------------+    |
|   |        Event Queue                          |    |
|   +---------------------------------------------+    |
|          |          |         |        |             |
|          v          v         v        v             |
|    +----------+  +----------+  +------------+        |
|    | I/O Ops  |  | Timer    |  | Callbacks  |  ...   |
|    +----------+  +----------+  +------------+        |
|          |            |              |               |
|          v            v              v               |
|    +------------------------------------------------+|
|    |            Worker Threads (if needed)         | |
|    +------------------------------------------------+|
|          |            |              |               |
|          v            v              v               |
|    +---------------------------------------------+   |
|    |           Results / Responses               |   |
|    +---------------------------------------------+   |
|          |          |         |        |             |
|          v          v         v        v             |
|    +---------------------------------------------+   |
|    |        Send Response to Client              |   |
|    +---------------------------------------------+   |
+------------------------------------------------------+
```

## Advantages of Node.js

1. High Performance: Due to the V8 engine and event-driven architecture.
2. JavaScript Everywhere: Enables the use of a single programming language for both client and server-side development.
3. Rich Ecosystem: A vast number of libraries and tools available through npm.
4. Active Community: A large and active community that contributes to continuous improvement and innovation.

## Disadvantages of Node.js

1. Single-Threaded Limitation: While efficient for I/O-bound operations, it may not be as effective for CPU-intensive tasks.
2. Callback Hell: Due to its asynchronous nature, extensive use of callbacks can lead to complex and hard-to-maintain code, although modern practices like Promises and async/await have mitigated this issue.
